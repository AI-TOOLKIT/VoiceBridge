/*
Copyright 2017-present Zoltan Somogyi (AI-TOOLKIT), All Rights Reserved
	You may use this file only if you agree to the software license:
	AI-TOOLKIT Open Source Software License - Version 2.0 - January 9, 2018:
	https://ai-toolkit.blogspot.com/p/ai-toolkit-open-source-software-license.html.
	Also included with the source code distribution in AI-TOOLKIT-LICENSE.txt.

Based on : Copyright 2010-2012 Microsoft Corporation 
		   Copyright 2012  Johns Hopkins University (Author: Daniel Povey), Apache 2.0.
           Arnab Ghoshal, 2014  Guoguo Chen, 2015  Hainan Xu, 2016 FAU Erlangen (Author: Axel Horndasch)
*/

#include "kaldi-win\scr\kaldi_scr.h"
#include "kaldi-win/scr/Params.h"

void WriteWordBoundary(StringTable table, fs::ofstream & file)
{
	static const boost::regex reB("_B$"); //begin
	static const boost::regex reI("_I$"); //internal
	static const boost::regex reE("_E$"); //end
	static const boost::regex reS("_S$"); //singleton
										  //nonword
	boost::match_results<std::string::const_iterator> match_results;
	boost::match_flag_type flags = boost::match_default;
	for (StringTable::const_iterator it(table.begin()), it_end(table.end()); it != it_end; ++it)
	{
		if (boost::regex_search((*it)[0], match_results, reB, flags))
			file << (*it)[0] << " " << "begin" << "\n";
		else if (boost::regex_search((*it)[0], match_results, reI, flags))
			file << (*it)[0] << " " << "internal" << "\n";
		else if (boost::regex_search((*it)[0], match_results, reE, flags))
			file << (*it)[0] << " " << "end" << "\n";
		else if (boost::regex_search((*it)[0], match_results, reS, flags))
			file << (*it)[0] << " " << "singleton" << "\n";
		else
			file << (*it)[0] << " " << "nonword" << "\n";
	}
}


// -> unk_fst = ""
//	if you want to model the unknown - word(<oov - dict - entry>) with a phone - level LM as created by make_unk_lm.sh,
//	provide the text - form FST via this flag, e.g. <work - dir> / unk_fst.txt
//	where <work - dir> was the 2nd argument of make_unk_lm.sh.
// -> phone_symbol_table =	"" 	
//	if set, use a specified phones.txt file.
// -> extra_word_disambig_syms = ""	
//	if set, add disambiguation symbols from this file(one per line) to phones / disambig.txt, phones / wdisambig.txt and words.txt
VOICEBRIDGE_API int PrepareLang(bool position_dependent_phones, fs::path unk_fst, fs::path phone_symbol_table, fs::path extra_word_disambig_syms)
{
	// Begin configuration section ------------------------------------>
	//NOTE: can add all as parameter
	int num_sil_states = 5;
	int num_nonsil_states = 3;
	// position_dependent_phones is false also when position dependent phones and word_boundary.txt
	// have been generated by another source
	bool share_silence_phones = false;  //if true, then share pdfs of different silence phones together.
	double sil_prob = 0.5;
	int num_extra_phone_disambig_syms = 1;
	// Standard one phone disambiguation symbol is used for optional silence.
	// Increasing this number does not harm, but is only useful if you later
	// want to introduce this labels to L_disambig.fst
	// <-------------------------------------- end configuration sections

	//TODO:... add these as parameter to this function?
	fs::path srcdir(voicebridgeParams.pth_dict);
	fs::path tmpdir(voicebridgeParams.pth_local / "lang");
	fs::path dir(voicebridgeParams.pth_lang);
	fs::path path_phones(dir / "phones");

	try
	{
		if (!fs::exists(path_phones)) fs::create_directories(path_phones);
		if (!fs::exists(tmpdir)) fs::create_directories(tmpdir);
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}

	bool silprob = false;
	if (fs::exists(srcdir / "lexiconp_silprob.txt")) silprob = true;

	try
	{
		if (ValidateDict(srcdir) < 0) return -1;
		LOGTW_INFO << "  --> Dictionaries are validated with succes in " << voicebridgeParams.pth_dict.string() << ".";
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}

	fs::path lex(srcdir / "lexicon.txt");
	fs::path lexp(srcdir / "lexiconp.txt");
	////read in lexiconp.txt => trasfer line => save to lexicon.txt		
	if (!fs::exists(lex) || fs::is_empty(lex))
	{
		LOGTW_INFO << "  --> Creating " << lex.string() << " from " << lexp.string() << ".";
		//read in lexiconp.txt => trasfer line => save to lexicon.txt		
		//replace strings:
		// => put the first part then skip the next and then put the rest of the line
		//NOTE: ofstream write adds an '\r' in front of the '\n' automatically and some code in Kaldi crashes. To prevent this
		//		add std::ios::binary option to each ofstream to make sure that '\r' is not added!
		fs::ofstream file_lex(lex, std::ios::binary);
		if (!file_lex) {
			LOGTW_ERROR << "Can't open output file: " << lex.string() << ".";
			return -1;
		}
		try
		{
			StringTable table_lexp = readData(lexp.string());
			int c = 0;
			for (StringTable::const_iterator it(table_lexp.begin()), it_end(table_lexp.end()); it != it_end; ++it)
			{
				c = 0;
				for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1) {
					if (c > 1) file_lex << " "; //Separator!
					if (c != 1) { //skip the second part (probability?)
						std::string s(*itc1);
						file_lex << s;
					}
					c++;
				}
				file_lex << '\n';
			}
		}
		catch (std::exception const& e)
		{
			LOGTW_FATALERROR << " " << e.what() << ".";
			return -1;
		}
		catch (...)
		{
			LOGTW_FATALERROR << " Unknown Error.";
			return -1;
		}
		file_lex.flush(); file_lex.close();

	}
	////read in lexiconp.txt => add 1.0 => save to lexicon.txt
	if (!fs::exists(lexp) || fs::is_empty(lexp))
	{
		LOGTW_INFO << "  --> Creating " << lexp.string() << " from " << lex.string() << ".";
		//read in lexiconp.txt => add 1.0 => save to lexicon.txt
		// => after the first part insert a 1.0 followed by a TAB and then the rest of the line 
		//NOTE: changed the TAB to space!
		//NOTE: ofstream write adds an '\r' in front of the '\n' automatically and some code in Kaldi crashes. To prevent this
		//		add std::ios::binary option to each ofstream to make sure that '\r' is not added!
		fs::ofstream file_lexp(lexp, std::ios::binary);
		if (!file_lexp) {
			LOGTW_ERROR << " can't open output file: " << lexp.string() << ".";
			return -1;
		}
		try
		{
			StringTable table_lex = readData(lex.string());
			int c = 0;
			for (StringTable::const_iterator it(table_lex.begin()), it_end(table_lex.end()); it != it_end; ++it)
			{
				c = 0;
				for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1) {
					if (c > 0) file_lexp << " "; //Separator!
					if (c == 1) { //add 1.0 (probability)
						file_lexp << "1.0 ";
					}
					std::string s(*itc1);
					file_lexp << s;
					c++;
				}
				file_lexp << '\n';
			}
		}
		catch (std::exception const& e)
		{
			LOGTW_FATALERROR << " " << e.what() << ".";
			return -1;
		}
		catch (...)
		{
			LOGTW_FATALERROR << " Unknown Error.";
			return -1;
		}
		file_lexp.flush(); file_lexp.close();

	}

	//read in the pth_silence_phones_txt and pth_nonsilence_phones_txt because they are needed several times
	//create also a merged version because that is also needed several times
	StringTable table_silence_phones, table_nonsilence_phones, table_silence_phones_nonsilence_phones;
	try
	{
		table_silence_phones = readData(voicebridgeParams.pth_silence_phones_txt.string());
		table_nonsilence_phones = readData(voicebridgeParams.pth_nonsilence_phones_txt.string());
		table_silence_phones_nonsilence_phones.insert(std::end(table_silence_phones_nonsilence_phones), std::begin(table_silence_phones), std::end(table_silence_phones));
		table_silence_phones_nonsilence_phones.insert(std::end(table_silence_phones_nonsilence_phones), std::begin(table_nonsilence_phones), std::end(table_nonsilence_phones));
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}

	//use phone_symbol_table if requested
	if (fs::exists(phone_symbol_table) && !fs::is_empty(phone_symbol_table))
	{
		// Checks if we have position dependent phones
		std::ifstream ifs(phone_symbol_table.string());
		if (!ifs) {
			LOGTW_ERROR << " Error opening file: " << phone_symbol_table.string() << ".";
			return -1;
		}
		std::string line;
		std::vector<std::string> vSymbols1, vSymbols2, _phones;
		int nLine = 0;
		static const boost::regex rexp1("^#[0-9]+$");
		static const boost::regex rexp2("_[BIES]$");
		boost::match_results<std::string::const_iterator> results;
		boost::match_flag_type flags = boost::match_default;
		while (std::getline(ifs, line)) {
			nLine++;

			//extract the columns with strtk
			std::vector<std::string> _words;
			strtk::parse(line, " \t", _words, strtk::split_options::compress_delimiters);

			//take only lines which are not matching "^#[0-9]+$" regular expression
			if (!boost::regex_match(line, results, rexp1))
			{
				//only add the first column and do not allow duplicates
				if (std::find(vSymbols1.begin(), vSymbols1.end(), _words[0]) == vSymbols1.end())
					vSymbols1.push_back(_words[0]);

				if (boost::regex_search(_words[0], results, rexp2, flags))
				{//if ends with the specific characters
				 //only add the first column and do not allow duplicates
					if (std::find(vSymbols2.begin(), vSymbols2.end(), _words[0]) == vSymbols2.end())
						vSymbols2.push_back(_words[0]);
				}
			}
			//add the first column/part to _phones but replace any special characters regular expression: "_[BIES]$"
			std::string s = boost::regex_replace(_words[0], rexp2, "");
			_phones.push_back(s);
		}

		//NOTE: in the perl version there is a 'sort -u' but it does not seem to be needed here //std::sort(vSymbols.begin(), vSymbols.end()); 
		size_t n1 = vSymbols1.size();
		size_t n2 = vSymbols2.size();
		if (position_dependent_phones && n1 == n2) {
			LOGTW_ERROR << " Position dependent phones requested, but do not appear in the provided phones.txt.";
			return -1;
		}
		if (!position_dependent_phones && n1 != n2) {
			LOGTW_ERROR << " Position dependent phones not requested, but appear in the provided phones.txt.";
			return -1;
		}
		// Checks if the phone sets match. Check both files nonsilence_phones.txt and silence_phones.txt against $phone_symbol_table
		ifs.clear();
		ifs.seekg(0);

		//add both tables for checking (only 1 column)
		std::vector<std::string> _both;
		for (StringTable::const_iterator it(table_silence_phones.begin()), it_end(table_silence_phones.end()); it != it_end; ++it)
			_both.push_back((*it)[0]);
		for (StringTable::const_iterator it(table_nonsilence_phones.begin()), it_end(table_nonsilence_phones.end()); it != it_end; ++it)
			_both.push_back((*it)[0]);

		for (int i = 0; i < _both.size(); ++i)
		{
			if (std::find(_phones.begin(), _phones.end(), _both[i]) == _phones.end())
			{ //not found
				LOGTW_ERROR << " Phone " << _both[i] << " appears in the lexicon but not in the provided phones.txt.";
				return -1;
			}
		}
	}

	// In case there are extra word-level disambiguation symbols we need to make sure that all symbols in the provided file are valid.
	if (fs::exists(extra_word_disambig_syms) && !fs::is_empty(extra_word_disambig_syms))
	{
		if (ValidateDisambigSymFile(extra_word_disambig_syms, false) < 0) return -1;
	}

	// Create tmpdir / lexiconp.txt from srcdir / lexiconp.txt (or tmpdir / lexiconp_silprob.txt from srcdir / lexiconp_silprob.txt) by
	// adding the markers _B, _E, _S, _I depending on word position. In this recipe, these markers apply to silence also.
	// Do this starting from lexiconp.txt only.
	if (position_dependent_phones == true)
	{
		if (silprob)
		{
			//create new file
			fs::path tmpdir_lexiconp_silprob_txt(tmpdir / "lexiconp_silprob.txt");
			fs::ofstream file_tmpdir_lexiconp_silprob_txt(tmpdir_lexiconp_silprob_txt, std::ios::binary);
			if (!file_tmpdir_lexiconp_silprob_txt) {
				LOGTW_ERROR << "Can't open output file: " << tmpdir_lexiconp_silprob_txt.string() << ".";
				return -1;
			}
			//read the input data from srcdir/lexiconp_silprob.txt (pth_lexiconp_silprob_txt) and make new file
			try
			{
				StringTable table = readData(voicebridgeParams.pth_lexiconp_silprob_txt.string());
				if (table.size() < 1)
				{
					LOGTW_ERROR << "There is no data in file: " << voicebridgeParams.pth_lexiconp_silprob_txt.string() << ".";
					return -1;
				}
				else if (table[0].size() < 6)
				{
					LOGTW_ERROR << "There are not enough data columns in file: " << voicebridgeParams.pth_lexiconp_silprob_txt.string() << ".";
					return -1;
				}
				int c = 0;
				//
				for (StringTable::const_iterator it(table.begin()), it_end(table.end()); it != it_end; ++it)
				{
					c = 0;
					int nCols = (int)it->size(); 
					for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
					{
						if (c > 0) file_tmpdir_lexiconp_silprob_txt << " "; //Separator!
						file_tmpdir_lexiconp_silprob_txt << *itc1;

						if (nCols == 6) {
							if (c == 5) file_tmpdir_lexiconp_silprob_txt << "_S";
						}
						else {
							if (c == 5) file_tmpdir_lexiconp_silprob_txt << "_B";
							else if (c < nCols - 1) file_tmpdir_lexiconp_silprob_txt << "_I";
							else  file_tmpdir_lexiconp_silprob_txt << "_E";
						}
						c++;
					}
					file_tmpdir_lexiconp_silprob_txt << '\n';
				}
			}
			catch (std::exception const& e)
			{
				LOGTW_FATALERROR << " " << e.what() << ".";
				return -1;
			}
			catch (...)
			{
				LOGTW_FATALERROR << " Unknown Error.";
				return -1;
			}
			file_tmpdir_lexiconp_silprob_txt.flush(); file_tmpdir_lexiconp_silprob_txt.close();
		} ///if (silprob)
		else 
		{
			//create new file
			fs::path tmpdir_lexiconp_txt(tmpdir / "lexiconp.txt");
			fs::ofstream file_tmpdir_lexiconp_txt(tmpdir_lexiconp_txt, std::ios::binary);
			if (!file_tmpdir_lexiconp_txt) {
				LOGTW_ERROR << " can't open output file: " << tmpdir_lexiconp_txt.string() << ".";
				return -1;
			}
			//read the input data from srcdir/lexiconp.txt (pth_lexiconp_txt) and make new file
			try
			{
				StringTable table = readData(voicebridgeParams.pth_lexiconp_txt.string());
				if (table.size() < 1) 
				{
					LOGTW_ERROR << " there is no data in file: " << voicebridgeParams.pth_lexiconp_txt.string() << ".";
					return -1;
				}
				else if (table[0].size() < 3) 
				{
					LOGTW_ERROR << " there are not enough data columns in file: " << voicebridgeParams.pth_lexiconp_txt.string() << ".";
					return -1;
				}
				int c = 0;
				//
				for (StringTable::const_iterator it(table.begin()), it_end(table.end()); it != it_end; ++it)
				{
					c = 0;
					int nCols = (int)it->size(); 
					for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1) 
					{
						if (c > 0) file_tmpdir_lexiconp_txt << " "; //Separator!
						file_tmpdir_lexiconp_txt << *itc1;
						//add position symbol
						if (nCols == 3) 
						{//special case
							if (c == 2) file_tmpdir_lexiconp_txt << "_S";
						}
						else {
							if (c == 2) file_tmpdir_lexiconp_txt << "_B";
							else if (c == nCols - 1) file_tmpdir_lexiconp_txt << "_E";
							else if (c > 2) file_tmpdir_lexiconp_txt << "_I";
						}
						c++;
					}
					file_tmpdir_lexiconp_txt << '\n';
				}
			}
			catch (std::exception const& e)
			{
				LOGTW_FATALERROR << " " << e.what() << ".";
				return -1;
			}
			catch (...)
			{
				LOGTW_FATALERROR << " Unknown Error.";
				return -1;
			}
			file_tmpdir_lexiconp_txt.flush(); file_tmpdir_lexiconp_txt.close();
		} //else

		// create tmpdir / phone_map.txt this has the format(on each line) 
		// <original phone> <version 1 of original phone> <version 2> ...
		// where the versions depend on the position of the phone within a word. For instance, we'd have:
		//		AA AA_B AA_E AA_I AA_S for (B)egin, (E)nd, (I)nternal and (S)ingleton and in the case of silence
		//		SIL SIL SIL_B SIL_E SIL_I SIL_S
		// [because SIL on its own is one of the variants; this is for when it doesn't occur inside a word
		//but as an option in the lexicon.]
		//
		/*Example phone_map.txt

			sil sil sil_B sil_E sil_I sil_S
			spn spn spn_B spn_E spn_I spn_S
			phoneb phoneb_B phoneb_E phoneb_I phoneb_S
			phonea phonea_B phonea_E phonea_I phonea_S
			phonec phonec_B phonec_E phonec_I phonec_S
		*/
		// This phone map expands the phone lists into all the word - position - dependent versions of the phone lists.
		fs::ofstream file_tmp(tmpdir / "phone_map.txt", std::ios::binary);
		if (!file_tmp) {
			LOGTW_ERROR << " can't open output file: " << tmpdir / "phone_map.txt" << ".";
			return -1;
		}
		//silence
		for (StringTable::const_iterator it(table_silence_phones.begin()), it_end(table_silence_phones.end()); it != it_end; ++it)
		{			
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
			{				
				int c = 0;
				for (int i = 0; i < 6; i++) {
					std::string s(*itc1);
					if (c > 0) file_tmp << " "; //Separator!
					
					//append if needed _B, _E, ...
					if (i == 2) s = s.append("_B");
					else if (i == 3) s = s.append("_E");
					else if (i == 4) s = s.append("_I");
					else if (i == 5) s=s.append("_S");
					
					file_tmp << s;
					c++;
				}
				file_tmp << '\n'; 
			}

		}
		//nonsilence
		for (StringTable::const_iterator it(table_nonsilence_phones.begin()), it_end(table_nonsilence_phones.end()); it != it_end; ++it)
		{
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
			{			
				int c = 0;
				for (int i = 0; i < 5; i++) {
					std::string s(*itc1);
					if (c > 0) file_tmp << " "; //Separator!

					//append if needed _B, _E, ...
					if (i == 1) s = s.append("_B");
					else if (i == 2) s = s.append("_E");
					else if (i == 3) s = s.append("_I");
					else if (i == 4) s = s.append("_S");

					file_tmp << s;
					c++;
				}
				file_tmp << '\n'; 
			}

		}
		file_tmp.flush(); file_tmp.close();

	} ///if (position_dependent_phones)
	else 
	{
		try
		{
			if (silprob) {
				fs::path tmpdir_lexiconp_silprob_txt(tmpdir / "lexiconp_silprob.txt");
				if (!fs::exists(tmpdir_lexiconp_silprob_txt.branch_path())) fs::create_directories(tmpdir_lexiconp_silprob_txt.branch_path());
				fs::copy_file(voicebridgeParams.pth_lexiconp_silprob_txt, tmpdir_lexiconp_silprob_txt, fs::copy_option::overwrite_if_exists);
			}
			else {
				fs::path tmpdir_lexiconp_txt(tmpdir / "lexiconp.txt");
				if (!fs::exists(tmpdir_lexiconp_txt.branch_path())) fs::create_directories(tmpdir_lexiconp_txt.branch_path());
				fs::copy_file(voicebridgeParams.pth_lexiconp_txt, tmpdir_lexiconp_txt, fs::copy_option::overwrite_if_exists);
			}
		}
		catch (std::exception const& e)
		{
			LOGTW_FATALERROR << " " << e.what() << ".";
			return -1;
		}
		catch (...)
		{
			LOGTW_FATALERROR << " Unknown Error.";
			return -1;
		}

		//NOTE: the below copies the fields 2 times horizontally (the same)
		//read both files silence_phones.txt and nonsilence_phones.txt and output all fields (columns) to the new file tmpdir/phones.tmp		
		fs::ofstream file_tmp(tmpdir / "phone_map.txt", std::ios::binary);
		if (!file_tmp) {
			LOGTW_ERROR << " can't open output file: " << tmpdir / "phone_map.txt" << ".";
			return -1;
		}

		for (StringTable::const_iterator it(table_silence_phones_nonsilence_phones.begin()), it_end(table_silence_phones_nonsilence_phones.end()); it != it_end; ++it)
		{
			//NOTE: there is only 1 column in the phone file, the below is not really needed
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
			{
				//NOTE: we force each column/field to one column by adding a line break! (in case there would be more columns)
				file_tmp << *itc1 << " " << *itc1 << '\n';
			}
		}

		file_tmp.flush(); file_tmp.close();
	} ///else  ==> if (position_dependent_phones == true)

	//---------------------------------------------------------------------
	// Sets of phones for use in clustering, and making monophone systems 
	//-----------------------------------------------------------------------
	//check if the phone_map.txt is created in the former stepp well
	fs::path path_phone_map(tmpdir / "phone_map.txt");
	if (CheckFileExistsAndNotEmpty(path_phone_map, true) < 0) return -1;
	StringTable table_map;
	if (ReadStringTable(path_phone_map.string(), table_map) < 0) return -1;
	if (share_silence_phones) 
	{
		// Build a roots file that will force all the silence phones to share the same pdf's. [three distinct states, 
		// only the transitions will differ.] 'shared'/'not-shared' means, do we share the 3 states of the HMM
		// in the same tree - root ? Sharing across models(phones) is achieved by writing several phones
		// into one line of roots.txt(shared / not- shared doesn't affect this). 'not-shared not-split' means we have 
		// separate tree roots for the 3 states, but we never split the tree so they remain stumps,
		// so all phones in the line correspond to the same model.
		StringTable input_text;
		std::vector<std::string> row;
		//tranpose the table_silence_phones to one line
		for (StringTable::const_iterator it(table_silence_phones.begin()), it_end(table_silence_phones.end()); it != it_end; ++it)
		{
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
			{
				row.push_back(*itc1);
			}
		}
		input_text.push_back(row);
		//add the table_nonsilence_phones
		input_text.insert(std::end(input_text), std::begin(table_nonsilence_phones), std::end(table_nonsilence_phones));
		fs::path output_file_path(path_phones / "sets.txt");
		if (ApplyMap(table_map, input_text, output_file_path, 0, -1, false) < 0) return -1;

		fs::ofstream file_roots(path_phones / "roots.txt", std::ios::binary);
		if (!file_roots) {
			LOGTW_ERROR << "Can't open output file: " << path_phones / "roots.txt" << ".";
			return -1;
		}
		std::ifstream ifs_sets(output_file_path.string());
		if (!ifs_sets) {
			LOGTW_ERROR << "Error opening file: " << output_file_path.string() << ".";
			return -1;
		}
		std::string line;
		int nr = 0;
		while (std::getline(ifs_sets, line)) {
			if(nr==0)
				file_roots << "not-shared not-split " << line << "\n";
			else
				file_roots << "shared split " << line << "\n";
			nr++;
		}		
		file_roots.flush(); file_roots.close();

	} ///if (share_silence_phones) 
	else 
	{
		//Different silence phones will have different GMMs.  [note: here, all "shared split" means
		//is that we may have one GMM for all the states, or we can split on states.  because they're
		//context-independent phones, they don't see the context.]
		fs::path output_file_path(path_phones / "sets.txt");		
		if (ApplyMap(table_map, table_silence_phones_nonsilence_phones, output_file_path, 0, -1, false) < 0) return -1;

		//cat $dir / phones / sets.txt | awk '{print "shared", "split", $0;}' > $dir / phones / roots.txt
		fs::ofstream file_roots(path_phones / "roots.txt", std::ios::binary);
		if (!file_roots) {
			LOGTW_ERROR << "Can't open output file: " << path_phones / "roots.txt" << ".";
			return -1;
		}
		std::ifstream ifs_sets(output_file_path.string());
		if (!ifs_sets) {
			LOGTW_ERROR << "Error opening file: " << output_file_path.string() << ".";
			return -1;
		}
		std::string line;
		while (std::getline(ifs_sets, line)) {
			file_roots << "shared split " << line << "\n";
		}
		file_roots.flush(); file_roots.close();
	} ///else ///if (share_silence_phones) 

	//SILENCE
	//NOTE: we create here an extra temporary file
	fs::path path_silence_temp(path_phones / "silence.temp");
	if (ApplyMap(table_map, table_silence_phones, path_silence_temp, 0, -1, false) < 0) return -1;
	//read in the created file
	StringTable table_silence_temp;
	if (ReadStringTable(path_silence_temp.string(), table_silence_temp) < 0) return -1;
	//create output file
	fs::ofstream file_silence_txt(path_phones / "silence.txt", std::ios::binary);
	if (!file_silence_txt) {
		LOGTW_ERROR << "Can't open output file: " << path_phones / "silence.txt" << ".";
		return -1;
	}
	//populate silence.txt
	for (StringTable::const_iterator it(table_silence_temp.begin()), it_end(table_silence_temp.end()); it != it_end; ++it)
	{
		for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
		{
			//NOTE: we print each column also on a new line! The file will contain only 1 column of data.
			file_silence_txt << *itc1 << "\n";
		}
	}
	file_silence_txt.flush(); file_silence_txt.close();

	//NOTE: do the same for the nonsilence_phones.txt as above for the silence_phones.txt
	//NONSILENCE
	//NOTE: we create here an extra temporary file
	fs::path path_nonsilence_temp(path_phones / "nonsilence.temp");
	if (ApplyMap(table_map, table_nonsilence_phones, path_nonsilence_temp, 0, -1, false) < 0) return -1;
	//read in the created file
	StringTable table_nonsilence_temp;
	if (ReadStringTable(path_nonsilence_temp.string(), table_nonsilence_temp) < 0) return -1;
	//create output file
	fs::ofstream file_nonsilence_txt(path_phones / "nonsilence.txt", std::ios::binary);
	if (!file_nonsilence_txt) {
		LOGTW_ERROR << "Can't open output file: " << path_phones / "nonsilence.txt" << ".";
		return -1;
	}
	//populate silence.txt
	for (StringTable::const_iterator it(table_nonsilence_temp.begin()), it_end(table_nonsilence_temp.end()); it != it_end; ++it)
	{
		for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
		{
			//NOTE: we print each column also on a new line! The file will contain only 1 column of data.
			file_nonsilence_txt << *itc1 << "\n";
		}
	}
	file_nonsilence_txt.flush(); file_nonsilence_txt.close();

	try
	{
		fs::copy_file(voicebridgeParams.pth_optional_silence_txt, path_phones / "optional_silence.txt", fs::copy_option::overwrite_if_exists);
		fs::copy_file(path_phones / "silence.txt", path_phones / "context_indep.txt", fs::copy_option::overwrite_if_exists);
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}

	// if extra_questions.txt is empty, it's OK.
	StringTable table_extra_questions_txt;
	if (fs::exists(voicebridgeParams.pth_extra_questions_txt)) {
		table_extra_questions_txt = readData(voicebridgeParams.pth_extra_questions_txt.string());
		ApplyMap(table_map, table_extra_questions_txt, path_phones / "extra_questions.txt", 0, -1, false);
	}
	
	//Want extra questions about the word - start / word - end stuff.Make it separate for silence and non - silence.
	//Probably doesn't matter, as silence will rarely be inside a word.
	if (position_dependent_phones == true) 
	{
		//e.g. if the file is
		//A
		//B
		//then it will write to the output file
		//A_B B_B
		//A_E B_E
		//A_I B_I
		//A_S B_S
		//in case of nonsilence_phones.txt

		//NOTE:  this must be appended hence fs::ofstream::app!
		fs::ofstream file_extra_questions(path_phones / "extra_questions.txt", fs::ofstream::app);
		if (!file_extra_questions) {
			LOGTW_ERROR << " can't open output file: " << path_phones / "extra_questions.txt" << ".";
			return -1;
		}
		std::vector<std::string> suffixes_nonsilence = { "_B", "_E", "_I", "_S" };
		std::vector<std::string> suffixes_silence = { "", "_B", "_E", "_I", "_S" };
		//silence
		for each (std::string suffix in suffixes_silence) {
			for (StringTable::const_iterator it(table_silence_phones.begin()), it_end(table_silence_phones.end()); it != it_end; ++it)
			{
				int c = 0;
				//NOTE: there is only 1 column in the phone file, the below is not really needed
				for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
				{
					if (c > 0) file_extra_questions << " "; //Separator!
					file_extra_questions << *itc1 << suffix;
					c++;
				}
				file_extra_questions << '\n';
			}			
		}
		//nonsilence
		for each (std::string suffix in suffixes_nonsilence) {
			for (StringTable::const_iterator it(table_nonsilence_phones.begin()), it_end(table_nonsilence_phones.end()); it != it_end; ++it)
			{
				int c = 0;
				//NOTE: there is only 1 column in the phone file, the below is not really needed
				for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
				{
					if (c > 0) file_extra_questions << " "; //Separator!
					file_extra_questions << *itc1 << suffix;
					c++;
				}
				file_extra_questions << '\n';
			}			
		}
		file_extra_questions.flush(); file_extra_questions.close();
	}

	// add_lex_disambig is responsible for adding disambiguation symbols to the lexicon, for telling us how many disambiguation symbols 
	// it used, and and also for modifying the unknown - word's pronunciation (if the unk_fst parameter was provided) to the sequence 
	// "#1 #2 #3", and reserving those disambig symbols for that purpose.
	// The #2 will later be replaced with the actual unk model. The reason for the #1 and the #3 is for disambiguation and also to keep 
	// the FST compact. If we didn't have the #1, we might have a different copy of the unk - model FST, or at least some of its arcs, 
	// for each start - state from which an <unk> transition comes(instead of per end - state, which is more compact); and adding 
	// the #3 prevents us from potentially having 2 copies of the unk - model FST due to the 
	// optional - silence[the last phone of any word gets 2 arcs].
	int first_allowed_disambig = 1;
	if (fs::exists(unk_fst) && !fs::is_empty(unk_fst))
	{
		if (silprob) 
		{
			fs::path tmpdir_lexiconp_silprob_txt(tmpdir / "lexiconp_silprob.txt");
			if (ModifyUnkPron(tmpdir_lexiconp_silprob_txt, voicebridgeParams.oov_word) < 0) return -1;
		}
		else
		{
			fs::path tmpdir_lexiconp_txt(tmpdir / "lexiconp.txt");
			if (ModifyUnkPron(tmpdir_lexiconp_txt, voicebridgeParams.oov_word) < 0) return -1;
		}
		first_allowed_disambig = 4;
	}
	else {
		first_allowed_disambig = 1;
	}

	int ndisambig;
	if (silprob) {
		ndisambig = AddLexDisambig(true, true, first_allowed_disambig, tmpdir / "lexiconp_silprob.txt", tmpdir / "lexiconp_silprob_disambig.txt");
	}
	else {
		ndisambig = AddLexDisambig(true, false, first_allowed_disambig, tmpdir / "lexiconp.txt", tmpdir / "lexiconp_disambig.txt");
	}
	//add(at least) one disambig symbol for silence in lexicon FST.
	ndisambig += num_extra_phone_disambig_syms; 

	fs::ofstream file_lex_ndisambig(tmpdir / "lex_ndisambig", std::ios::binary);
	if (!file_lex_ndisambig) {
		LOGTW_ERROR << " can't open output file: " << tmpdir / "lex_ndisambig" << ".";
		return -1;
	}
	file_lex_ndisambig << ndisambig << "\n";
	file_lex_ndisambig.flush(); file_lex_ndisambig.close();

	/*
	 //Format of lexiconp_disambig.txt:

	 !SIL	1.0   SIL_S
	 <SPOKEN_NOISE>	1.0   SPN_S #1
	 <UNK>	1.0  SPN_S #2
	 <NOISE>	1.0  NSN_S
	 !EXCLAMATION-POINT	1.0  EH2_B K_I S_I K_I L_I AH0_I M_I EY1_I SH_I AH0_I N_I P_I OY2_I N_I T_E
	*/

	fs::ofstream file_disambig_txt(path_phones / "disambig.txt");
	if (!file_disambig_txt) {
		LOGTW_ERROR << " can't open output file: " << path_phones / "disambig.txt" << ".";
		return -1;
	}
	for(int n = 0; n <= ndisambig; n++)
		file_disambig_txt << "#" << n << "\n";	

	// In case there are extra word-level disambiguation symbols they also need to be added to the list of 
	// phone - level disambiguation symbols.
	//NOTE: must be appended to disambig.txt and not overwritten, therefore do not close the file yet!
	/*
	extra_word_disambig_syms
	if not empty, add disambiguation symbols from this file (one per line) to phones/disambig.txt,
	phones/wdisambig.txt and words.txt"
	*/
	StringTable table_extra_word_disambig_syms;
	if (fs::exists(extra_word_disambig_syms) && !fs::is_empty(extra_word_disambig_syms)) 
	{
		//We expect a file containing valid word-level disambiguation symbols.
		if (ReadStringTable(extra_word_disambig_syms.string(), table_extra_word_disambig_syms) < 0) return -1;
		for (StringTable::const_iterator it(table_extra_word_disambig_syms.begin()), it_end(table_extra_word_disambig_syms.end()); it != it_end; ++it)
		{
			file_disambig_txt << (*it)[0] << "\n";
		}
	}
	file_disambig_txt.flush(); file_disambig_txt.close();

	//[start] Create phone symbol table. ----------------------------------------------------------------------------->
	/* Example phone symbol table with disambiguation symbols
		<eps> 0
		ey 15
		k 22
		sil 42
		#0 43                     ====> start_symbol
		#1 44
		#2 45
		#3 46
	*/
	/* Example phones.txt
		<eps> 0
		sil 1
		sil_B 2
		sil_E 3
		sil_I 4
		sil_S 5
		spn 6
		spn_B 7
		spn_E 8
		spn_I 9
		spn_S 10
		phonea_B 11
		phonea_E 12
		phonea_I 13
		phonea_S 14
	*/
	//read in the input data
	StringTable table_silence, table_nonsilence, table_disambig;
	try
	{
		table_silence = readData((path_phones / "silence.txt").string());
		table_nonsilence = readData((path_phones / "nonsilence.txt").string());
		table_disambig = readData((path_phones / "disambig.txt").string());
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}
	//open the output phones.txt
	fs::ofstream file_phones_txt(dir / "phones.txt", std::ios::binary);
	if (!file_phones_txt) {
		LOGTW_ERROR << " can't open output file: " << dir / "phones.txt" << ".";
		return -1;
	}
	//
	if (fs::exists(phone_symbol_table) && !fs::is_empty(phone_symbol_table))
	{
		StringTable table_ps;
		int start_symbol = -1;
		try
		{
			table_ps = readData(phone_symbol_table.string());
		}
		catch (std::exception const& e)
		{
			LOGTW_FATALERROR << " " << e.what() << ".";
			return -1;
		}
		catch (...)
		{
			LOGTW_FATALERROR << " Unknown Error.";
			return -1;
		}
		for (StringTable::const_iterator it(table_ps.begin()), it_end(table_ps.end()); it != it_end; ++it)
		{
			if((*it)[0] == "#0")
			{
				if(is_positive_int((*it)[1]))
					start_symbol = std::stoi((*it)[1]);
				break;
			}
		}
		if (start_symbol < 0) {
			LOGTW_ERROR << " missing line with #0 for the start symbol in file: " << phone_symbol_table.string() << ".";
			return -1;
		}
		//make a new table for the sorting
		using MAPT = std::unordered_map<std::string, int>;
		MAPT firstPart;
		//get the 2nd field value from the phone symbol table
		int val;
		//add <eps>
		if(GetSecondFieldFromStringTable(table_ps, "<eps>", phone_symbol_table.string(), &val) < 0) return -1;
		firstPart.emplace("<eps>", val);
		//add the on the second field sorted silence.txt and nonsilence.txt
		for (StringTable::const_iterator it(table_silence.begin()), it_end(table_silence.end()); it != it_end; ++it)
		{
			if (GetSecondFieldFromStringTable(table_ps, (*it)[0], phone_symbol_table.string(), &val) < 0) return -1;
			firstPart.emplace((*it)[0], val);
		}
		for (StringTable::const_iterator it(table_nonsilence.begin()), it_end(table_nonsilence.end()); it != it_end; ++it)
		{
			if (GetSecondFieldFromStringTable(table_ps, (*it)[0], phone_symbol_table.string(), &val) < 0) return -1;
			firstPart.emplace((*it)[0], val);			
		}
		//use the sorted_snapshot_of template to automatically sort the map on the 2nd field (int)
		for (const auto& pair : sorted_snapshot_of(firstPart)) // gets a sorted (sorted on values, then keys) snapshot of the map
		{
			file_phones_txt << pair.first.get() << " " << pair.second.get() << "\n";
		}		
		//add disambig.txt
		int n = start_symbol;
		for (StringTable::const_iterator it(table_disambig.begin()), it_end(table_disambig.end()); it != it_end; ++it)
		{
			file_phones_txt << (*it)[0] << " " << n << "\n";
			n++;
		}
	} ///if (fs::exists(phone_symbol_table...
	else
	{
		int n = 0;
		file_phones_txt << "<eps> " << n << "\n";
		n++;
		for (StringTable::const_iterator it(table_silence.begin()), it_end(table_silence.end()); it != it_end; ++it)
		{
			file_phones_txt << (*it)[0] << " " << n << "\n";
			n++;
		}
		for (StringTable::const_iterator it(table_nonsilence.begin()), it_end(table_nonsilence.end()); it != it_end; ++it)
		{
			file_phones_txt << (*it)[0] << " " << n << "\n";
			n++;
		}
		for (StringTable::const_iterator it(table_disambig.begin()), it_end(table_disambig.end()); it != it_end; ++it)
		{
			file_phones_txt << (*it)[0] << " " << n << "\n";
			n++;
		}
	}
	file_phones_txt.flush(); file_phones_txt.close();
	//[end] Create phone symbol table. <-----------------------------------------------------------------------------

	//[start] Create a file that describes the word-boundary information for each phone.  5 categories.
	//open the output word_boundary.txt
	if (position_dependent_phones) 
	{
		fs::ofstream file_word_boundary_txt(path_phones / "word_boundary.txt", std::ios::binary);
		if (!file_word_boundary_txt) {
			LOGTW_ERROR << "Can't open output file: " << path_phones / "word_boundary.txt" << ".";
			return -1;
		}
		WriteWordBoundary(table_silence, file_word_boundary_txt);
		WriteWordBoundary(table_nonsilence, file_word_boundary_txt);
		file_word_boundary_txt.flush(); file_word_boundary_txt.close();
	}
	else 
	{
		//word_boundary.txt might have been generated by another source
		if (fs::exists(srcdir / "word_boundary.txt") && !fs::is_empty(srcdir / "word_boundary.txt"))
		{
			try	{
				fs::copy_file(srcdir / "word_boundary.txt", path_phones / "word_boundary.txt", fs::copy_option::overwrite_if_exists);
			}
			catch (std::exception const& e) {
				LOGTW_FATALERROR << " " << e.what() << ".";
				return -1;
			}
			catch (...) {
				LOGTW_FATALERROR << " Unknown Error.";
				return -1;
			}
		}
	}	
	//[end] Create a file that describes the word-boundary information for each phone.  5 categories.

	//[start] Create word symbol table. <s> and </s> are only needed due to the need to rescore lattices with
	// ConstArpaLm format language model. They do not normally appear in G.fst or L.fst.
	fs::path tmpdir_lexiconp_txt(tmpdir / "lexiconp.txt");
	if(silprob) 
	{
		// remove the silprob
		StringTable table_lexiconp_silprob;
		if (ReadStringTable((tmpdir / "lexiconp_silprob.txt").string(), table_lexiconp_silprob) < 0) return -1;
		fs::ofstream file_tmpdir_lexiconp_txt(tmpdir_lexiconp_txt, std::ios::binary);
		if (!file_tmpdir_lexiconp_txt) {
			LOGTW_ERROR << "Can't open output file: " << tmpdir_lexiconp_txt.string() << ".";
			return -1;
		}
		int c = 0;
		for (StringTable::const_iterator it(table_lexiconp_silprob.begin()), it_end(table_lexiconp_silprob.end()); it != it_end; ++it)
		{
			c = 1;
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1)
			{
				if (c != 3 && c != 4 && c != 5)
					//printf("%s\t", $i); 
					file_tmpdir_lexiconp_txt << c << "\t";
				c++;
			}
			file_tmpdir_lexiconp_txt << "\n";
		}
		file_tmpdir_lexiconp_txt.flush(); file_tmpdir_lexiconp_txt.close();
	}

	//make words.txt
	StringTable table_lexiconp;
	if (ReadStringTable(tmpdir_lexiconp_txt.string(), table_lexiconp) < 0) return -1;
	//NOTE: ofstream write adds an '\r' in front of the '\n' automatically and some code in Kaldi crashes. To prevent this
	//		add std::ios::binary option to each ofstream to make sure that '\r' is not added!
	fs::ofstream file_words_txt(dir / "words.txt", std::ios::binary);
	if (!file_words_txt) {
		LOGTW_ERROR << "Can't open output file: " << (dir / "words.txt").string() << ".";
		return -1;
	}
	std::vector<std::string> words;
	for (StringTable::const_iterator it(table_lexiconp.begin()), it_end(table_lexiconp.end()); it != it_end; ++it)
		words.push_back((*it)[0]);
	std::sort(words.begin(), words.end());
	words.erase(std::unique(words.begin(), words.end()), words.end());
	file_words_txt << "<eps> 0\n";
	int n = 1;
	for each(std::string s in words) 
	{
		if (s == "<s>" || s == "</s>") {
			LOGTW_ERROR << " <s> and </s> must not be in the vocabulary in file: " << tmpdir_lexiconp_txt.string() << ".";
			return -1;
		}
		file_words_txt << s << " " << n << "\n";
		n++;
	}
	file_words_txt << "#0" << " " << n << "\n";
	n++;
	file_words_txt << "<s>" << " " << n << "\n";
	n++;
	file_words_txt << "</s>" << " " << n << "\n";
	//store the word count for later
	int word_count = n;
	// In case there are extra word - level disambiguation symbols they also need to be added to words.txt
	if (fs::exists(extra_word_disambig_syms) && !fs::is_empty(extra_word_disambig_syms))
	{
		// We expect a file containing valid word - level disambiguation symbols.
		// The list of symbols is attached to the current words.txt(including a numeric identifier for each symbol).
		for (StringTable::const_iterator it(table_extra_word_disambig_syms.begin()), it_end(table_extra_word_disambig_syms.end()); it != it_end; ++it)
		{
			file_words_txt << (*it)[0] << " " << ++word_count << "\n";
		}
	}
	file_words_txt.flush(); file_words_txt.close();
	//[end] Create word symbol table. ------------------------------------------------------------------------------

	//read in optional_silence.txt - this should exists already, copied before
	StringTable table_optional_silence;
	if (ReadStringTable((srcdir / "optional_silence.txt").string(), table_optional_silence) < 0) return -1;

	//[start] create align_lexicon.txt-------------------------------------------------------------------------------
	// This is the method we use for lattice word alignment if we are not using word-position-dependent phones.
	// First remove pron - probs from the lexicon.
	fs::path tmpdir_lexiconp(tmpdir / "lexiconp.txt");
	fs::path tmpdir_align_lexicon(tmpdir / "align_lexicon.txt");	
	LOGTW_INFO << "  --> Creating " << tmpdir_align_lexicon.string() << " from " << tmpdir_lexiconp.string() << ".";
	// => put the first part then skip the next and then put the rest of the line
	fs::ofstream file_tmpdir_align_lexicon(tmpdir_align_lexicon, std::ios::binary);
	if (!file_tmpdir_align_lexicon) {
		LOGTW_ERROR << "Can't open output file: " << tmpdir_align_lexicon.string() << ".";
		return -1;
	}
	try
	{
		StringTable table_lexiconp = readData(tmpdir_lexiconp.string());
		int c = 0;
		for (StringTable::const_iterator it(table_lexiconp.begin()), it_end(table_lexiconp.end()); it != it_end; ++it)
		{
			c = 0;
			for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1) {
				if (c > 1) file_tmpdir_align_lexicon << " "; //Separator!
				if (c != 1) { //skip the second part (probability?)
					std::string s(*itc1);
					file_tmpdir_align_lexicon << s;
				}
				c++;
			}
			file_tmpdir_align_lexicon << '\n';
		}
	}
	catch (std::exception const& e)
	{
		LOGTW_FATALERROR << " " << e.what() << ".";
		return -1;
	}
	catch (...)
	{
		LOGTW_FATALERROR << " Unknown Error.";
		return -1;
	}
	// Note: here, silphone will have no suffix e.g. _S because it occurs as optional-silence, and is not part of a word.
	std::string silphone;
	if (fs::exists(srcdir / "optional_silence.txt") && !fs::is_empty(srcdir / "optional_silence.txt"))
	{
		//NOTE: only 1 optional silence symbol is allowed at the moment, therefore do not add more in any case!
		silphone = table_optional_silence[0][0];
		file_tmpdir_align_lexicon << "<eps> " << silphone << '\n';
	}

	file_tmpdir_align_lexicon.flush(); file_tmpdir_align_lexicon.close();

	//create phones / align_lexicon.txt
	StringTable table_align_lexicon;
	if (ReadStringTable((tmpdir / "align_lexicon.txt").string(), table_align_lexicon) < 0) return -1;
	fs::path path_phones_align_lexicon_txt(path_phones / "align_lexicon.txt");
	fs::ofstream file_phones_align_lexicon_txt(path_phones_align_lexicon_txt, std::ios::binary);
	if (!file_phones_align_lexicon_txt) {
		LOGTW_ERROR << "Can't open output file: " << path_phones_align_lexicon_txt.string() << ".";
		return -1;
	}
	//sort table
	// 1st store in : NOTE: automatically ordered and contains unique keys
	using MAPSS = std::map<std::string, std::string>;
	MAPSS mapSS;
	int c = 0;
	for (StringTable::const_iterator it(table_align_lexicon.begin()), it_end(table_align_lexicon.end()); it != it_end; ++it)
	{
		c = 0;
		std::string sFirst((*it)[0]);
		std::string sRest;
		for (string_vec::const_iterator itc1(it->begin()), itc1_end(it->end()); itc1 != itc1_end; ++itc1) {
			if (c > 1) sRest.append(" "); //Separator!
			if (c > 0) {
				sRest.append(*itc1);
			}
			c++;
		}
		mapSS.emplace(sFirst, sRest);
	}
	for (MAPSS::const_iterator it(mapSS.begin()), it_end(mapSS.end()); it != it_end; ++it)
	{
		file_phones_align_lexicon_txt << (*it).first << " " << (*it).first << " " << (*it).second << "\n";
	}
	file_phones_align_lexicon_txt.flush(); file_phones_align_lexicon_txt.close();
	//[end] create align_lexicon.txt-------------------------------------------------------------------------------

	//[start] create phones / align_lexicon.int -------------------------------------------------------------------
	//
	StringTable table_dir_phones, table_dir_words, table_align_lexicon_txt, table_phones_align_lexicon_int;
	fs::path path_phones_align_lexicon_int(path_phones / "align_lexicon.int");
	if (ReadStringTable((dir / "phones.txt").string(), table_dir_phones) < 0) return -1;
	if (ReadStringTable((dir / "words.txt").string(), table_dir_words) < 0) return -1;
	if (ReadStringTable((path_phones / "align_lexicon.txt").string(), table_align_lexicon_txt) < 0) return -1;
	//
	if (Sym2Int(table_dir_phones, table_align_lexicon_txt, path_phones_align_lexicon_int, 2, -1, "") < 0) return -1;
	//read in the output of the former call and pass it to the next
	if (ReadStringTable(path_phones_align_lexicon_int.string(), table_phones_align_lexicon_int) < 0) return -1;
	if (Sym2Int(table_dir_words, table_phones_align_lexicon_int, path_phones_align_lexicon_int, 0, 1, "") < 0) return -1;

	//[end] create phones / align_lexicon.int -------------------------------------------------------------------

	//[start] L.fst ---------------------------------------------------------------------------------------------
	// Create the basic L.fst without disambiguation symbols, for use in training.
	if (silprob)
	{
		StringTable table_lexiconp_silprob, table_silprob, table_lexiconfst;
		//a temporary file:
		fs::path path_temp_lexiconfst(tmpdir / "lexicon_fst_silprob.temp");
		//read input
		if (ReadStringTable((tmpdir / "lexiconp_silprob.txt").string(), table_lexiconp_silprob) < 0) return -1;
		if (ReadStringTable((srcdir / "silprob.txt").string(), table_silprob) < 0) return -1;
		//make temp file
		if (MakeLexiconFstSilprob(table_lexiconp_silprob, table_silprob, path_temp_lexiconfst, silphone, "<eps>") < 0) return -1;
		//compile the fst's and save them in the same temp file as above (overwrite)
		fs::path path_isymbols(dir / "phones.txt");
		fs::path path_osymbols(dir / "words.txt");
		//a temporary file:
		fs::path path_temp_lexiconfst_compiled(tmpdir / "lexicon_fst_compiled.temp");

		try
		{
			fstcompile(false, "standard", "vector",
				path_temp_lexiconfst.string(), path_temp_lexiconfst_compiled.string(),
				path_isymbols.string(), path_osymbols.string(), "",
				false, false, false, false);

		}
		catch (const std::exception& message)
		{
			LOGTW_ERROR << "Error while compiling fst's, check file: " << path_temp_lexiconfst.string() << "\nDetail: " << message.what() << ".";
			return -1;
		}

		//sort the fst's and write the final output
		fs::path path_L_FST(dir / "L.fst");
		fstarcsort("olabel", path_temp_lexiconfst_compiled.string(), path_L_FST.string());
	}
	else
	{
		StringTable table_lexiconp, table_lexiconfst;
		//a temporary file:
		fs::path path_temp_lexiconfst(tmpdir / "lexicon_fst.temp");
		//read input
		if (ReadStringTable((tmpdir / "lexiconp.txt").string(), table_lexiconp) < 0) return -1;
		//make temp file
		if (MakeLexiconFst(table_lexiconp, path_temp_lexiconfst, true, sil_prob, silphone, "") < 0) return -1;
		//compile the fst's and save them in the same temp file as above (overwrite)
		fs::path path_isymbols(dir / "phones.txt");
		fs::path path_osymbols(dir / "words.txt");
		//a temporary file:
		fs::path path_temp_lexiconfst_compiled(tmpdir / "lexicon_fst_compiled.temp");
		
		try
		{
			fstcompile(false, "standard", "vector",
				path_temp_lexiconfst.string(), path_temp_lexiconfst_compiled.string(),
				path_isymbols.string(), path_osymbols.string(), "",
				false, false, false, false);
		}
		catch (const std::exception& message)
		{
			LOGTW_ERROR << "Error while compiling fst's, check file: " << path_temp_lexiconfst.string() << "\nDetail: " << message.what() << ".";
			return -1;
		}

		//sort the fst's and write the final output
		fs::path path_L_FST(dir / "L.fst");
		fstarcsort("olabel", path_temp_lexiconfst_compiled.string(), path_L_FST.string());

	}
	//[end] L.fst ---------------------------------------------------------------------------------------------

	//[start] oov.txt -----------------------------------------------------------------------------------------
	// The file oov.txt contains a word that we will map any OOVs to during training.
	fs::path path_oov_txt(dir / "oov.txt");
	fs::ofstream file_oov_txt(path_oov_txt, std::ios::binary);
	if (!file_oov_txt) {
		LOGTW_ERROR << "Can't open output file: " << path_oov_txt.string() << ".";
		return -1;
	}
	file_oov_txt << voicebridgeParams.oov_word << "\n";
	file_oov_txt.flush(); file_oov_txt.close();

	//integer version of oov symbol, used in some scripts.
	StringTable table_oov_txt;
	fs::path path_oov_int(dir / "oov.int");
	if (ReadStringTable(path_oov_txt.string(), table_oov_txt) < 0) return -1;
	if (Sym2Int(table_dir_words, table_oov_txt, path_oov_int, -1, -1, "") < 0) return -1;
	//[end] oov.txt -------------------------------------------------------------------------------------------

	//[start] wdisambig.txt -----------------------------------------------------------------------------------
	//The file wdisambig.txt contains a(line - by - line) list of the text - form of the disambiguation symbols that 
	//are used in the grammar and passed through by the lexicon. At this stage it's hardcoded as '#0', 
	//but we're laying the groundwork for more generality(which probably would be added by another script).
	//wdisambig_words.int contains the corresponding list interpreted by the symbol table words.txt, 
	//and wdisambig_phones.int contains the corresponding list interpreted by the symbol table phones.txt.
	fs::path path_wdisambig_txt(path_phones / "wdisambig.txt");
	fs::ofstream file_wdisambig_txt(path_wdisambig_txt, std::ios::binary);
	if (!file_wdisambig_txt) {
		LOGTW_ERROR << "Can't open output file: " << path_wdisambig_txt.string() << ".";
		return -1;
	}
	file_wdisambig_txt << "#0" << "\n";	

	//In case there are extra word-level disambiguation symbols they need to be added to the existing word-level 
	//disambiguation symbols file.
	if (extra_word_disambig_syms != "")
	{
		//We expect a file containing valid word - level disambiguation symbols. The regular expression for awk 
		//is just a paranoia filter(e.g. for empty lines).
		//
		StringTable table_extra_word_disambig_syms;
		if (ReadStringTable(extra_word_disambig_syms.string(), table_extra_word_disambig_syms) < 0) return -1;
		for (StringTable::const_iterator it(table_extra_word_disambig_syms.begin()), it_end(table_extra_word_disambig_syms.end()); it != it_end; ++it)
		{
			file_wdisambig_txt << (*it)[0] << "\n";
		}
	}
	file_wdisambig_txt.flush(); file_wdisambig_txt.close();

	//
	StringTable table_wdisambig_txt;
	fs::path path_wdisambig_phones_int(path_phones / "wdisambig_phones.int");
	if (ReadStringTable(path_wdisambig_txt.string(), table_wdisambig_txt) < 0) return -1;
	if (Sym2Int(table_dir_phones, table_wdisambig_txt, path_wdisambig_phones_int, -1, -1, "") < 0) return -1;
	//
	fs::path path_wdisambig_words_int(path_phones / "wdisambig_words.int");
	if (Sym2Int(table_dir_words, table_wdisambig_txt, path_wdisambig_words_int, -1, -1, "") < 0) return -1;
	//[end] wdisambig.txt ---------------------------------------------------------------------------------------------

	//Create these lists of phones in colon - separated integer list form too, for purposes of being given to programs as command - line options.
	StringTable table_;
	std::vector<std::string> sfiles{ "silence", "nonsilence", "optional_silence", "disambig", "context_indep" };
	for each(std::string sf in sfiles) {
		//int
		if (ReadStringTable((path_phones / (sf + ".txt")).string(), table_) < 0) return -1;
		if (Sym2Int(table_dir_phones, table_, (path_phones / (sf + ".int")), -1, -1, "") < 0) return -1;
		//csl
		if (ReadStringTable((path_phones / (sf + ".int")).string(), table_) < 0) return -1;
		fs::ofstream file_1(path_phones / (sf + ".csl"), std::ios::binary);
		if (!file_1) {
			LOGTW_ERROR << "Can't open output file: " << (path_phones / (sf + ".csl")).string() << ".";
			return -1;
		}
		for (int i = 0; i < table_.size(); i++) {
			if (i > 0) file_1 << ":";
			file_1 << table_[i][0];
		}
		file_1 << "\n";
		file_1.flush(); file_1.close();
	}
	//sets, extra_questions
	std::vector<std::string> sfiles1{ "sets", "extra_questions" };
	for each(std::string sf in sfiles1) {
		//int
		if (fs::exists( (path_phones / (sf + ".txt")) )) 
		{//NOTE: extra_questions may not exist!
			if (ReadStringTable((path_phones / (sf + ".txt")).string(), table_) < 0) return -1;
			if (Sym2Int(table_dir_phones, table_, (path_phones / (sf + ".int")), -1, -1, "") < 0) return -1;
		}
	}
	//roots
	if (ReadStringTable((path_phones / "roots.txt").string(), table_) < 0) return -1;
	if (Sym2Int(table_dir_phones, table_, (path_phones / "roots.int"), 2, -1, "") < 0) return -1;
	//word_boundary
	if (fs::exists(path_phones / "word_boundary.txt")) {
		if (ReadStringTable((path_phones / "word_boundary.txt").string(), table_) < 0) return -1;
		if (Sym2Int(table_dir_phones, table_, (path_phones / "word_boundary.int"), 0, 0, "") < 0) return -1;
	}

	/*
	Note: it's OK, after generating the 'lang' directory, to overwrite the topo file with another one of your choice 
	if the 'topo' file you want can't be generated by utils/gen_topo.pl.  We do this in the 'chain' recipes. 
	Of course, the 'topo' file should cover all the phones.  Try running utils/validate_lang.pl to check that
	everything is OK after modifying the topo file.
	*/
	fs::path path_topo_output(dir / "topo");
	StringTable table_nonsilphonelist, table_silphonelist;
	if (ReadStringTable((path_phones / "nonsilence.csl").string(), table_nonsilphonelist) < 0) return -1;
	if (ReadStringTable((path_phones / "silence.csl").string(), table_silphonelist) < 0) return -1;
	if (GenerateTopology(num_nonsil_states, num_sil_states, table_nonsilphonelist, table_silphonelist, path_topo_output) < 0) return -1;

	/*
	 Create the lexicon FST with disambiguation symbols, and put it in lang_test. There is an extra step where we create a 
	 loop to "pass through" the disambiguation symbols from G.fst.
	*/
	//[start] L_disambig.fst ---------------------------------------------------------------------------------------------
	// Create the basic L.fst without disambiguation symbols, for use in training.
	if (silprob)
	{
		StringTable table_lexiconp_silprob, table_silprob, table_lexiconfst;
		//a temporary file:
		fs::path path_temp_lexiconfst(tmpdir / "lexicon_fst_silprob_disambig.temp");
		//read input
		if (ReadStringTable((tmpdir / "lexiconp_silprob_disambig.txt").string(), table_lexiconp_silprob) < 0) return -1;
		if (ReadStringTable((srcdir / "silprob.txt").string(), table_silprob) < 0) return -1;
		std::string sildisambig("#" + std::to_string(ndisambig));
		//make temp file
		if (MakeLexiconFstSilprob(table_lexiconp_silprob, table_silprob, path_temp_lexiconfst, silphone, sildisambig) < 0) return -1;
		//compile the fst's and save them in the same temp file as above (overwrite)
		fs::path path_isymbols(dir / "phones.txt");
		fs::path path_osymbols(dir / "words.txt");
		//a temporary file:
		fs::path path_temp_lexiconfst_compiled(tmpdir / "lexicon_fst_disambig_compiled.temp");

		try
		{
			fstcompile(false, "standard", "vector",
				path_temp_lexiconfst.string(), path_temp_lexiconfst_compiled.string(),
				path_isymbols.string(), path_osymbols.string(), "",
				false, false, false, false);

		}
		catch (const std::exception& message)
		{
			LOGTW_ERROR << "Error while compiling fst's, check file: " << path_temp_lexiconfst.string() << "\nDetail: " << message.what() << ".";
			return -1;
		}

		//add self-loops to fst
		fs::path inp(path_phones / "wdisambig_phones.int");
		fs::path outw(path_phones / "wdisambig_words.int");
		fs::path path_temp_lexiconfst_compiledL(tmpdir / "lexicon_fst_disambig_compiledL.temp");
		if (fstaddselfloops(path_temp_lexiconfst_compiled.string(), path_temp_lexiconfst_compiledL.string(), inp.string(), outw.string()) < 0) return -1;

		//sort the fst's and write the final output
		fs::path path_L_FST(dir / "L_disambig.fst");
		fstarcsort("olabel", path_temp_lexiconfst_compiledL.string(), path_L_FST.string());
	}
	else
	{
		StringTable table_lexiconp, table_lexiconfst;
		//a temporary file:
		fs::path path_temp_lexiconfst(tmpdir / "lexicon_fst_disambig.temp");
		//read input
		if (ReadStringTable((tmpdir / "lexiconp_disambig.txt").string(), table_lexiconp) < 0) return -1;
		std::string sildisambig("#" + std::to_string(ndisambig));
		//make temp file
		if (MakeLexiconFst(table_lexiconp, path_temp_lexiconfst, true, sil_prob, silphone, sildisambig) < 0) return -1;
		//compile the fst's and save them in the same temp file as above (overwrite)
		fs::path path_isymbols(dir / "phones.txt");
		fs::path path_osymbols(dir / "words.txt");
		//a temporary file:
		fs::path path_temp_lexiconfst_compiled(tmpdir / "lexicon_fst_disambig_compiled.temp");

		try
		{
			fstcompile(false, "standard", "vector",
				path_temp_lexiconfst.string(), path_temp_lexiconfst_compiled.string(),
				path_isymbols.string(), path_osymbols.string(), "",
				false, false, false, false);
		}
		catch (const std::exception& message)
		{
			LOGTW_ERROR << "Error while compiling fst's, check file: " << path_temp_lexiconfst.string() << "\nDetail: " << message.what() << ".";
			return -1;
		}

		//add self-loops to fst
		fs::path inp(path_phones / "wdisambig_phones.int");
		fs::path outw(path_phones / "wdisambig_words.int");
		fs::path path_temp_lexiconfst_compiledL(tmpdir / "lexicon_fst_disambig_compiledL.temp");
		if (fstaddselfloops(path_temp_lexiconfst_compiled.string(), path_temp_lexiconfst_compiledL.string(), inp.string(), outw.string()) < 0) return -1;

		//sort the fst's and write the final output
		fs::path path_L_FST(dir / "L_disambig.fst");
		fstarcsort("olabel", path_temp_lexiconfst_compiledL.string(), path_L_FST.string());

	}
	//[end] L_disambig.fst ---------------------------------------------------------------------------------------------

	if (fs::exists(unk_fst) && !fs::is_empty(unk_fst))
	{
		StringTable table_unk;
		if (ReadStringTable(unk_fst.string(), table_unk) < 0) return -1;
		if (ApplyUnkLM(table_unk, dir) < 0) return -1;

		if (!position_dependent_phones) 
		{
			LOGTW_WARNING << "You are using the phone-level LM (unk_fst) option and setting position dependent phones to false (position_dependent_phones). "
				<< "This will make it impossible to properly work out the word boundaries after decoding and will make several built-in functions fail.";
		}
	}

	LOGTW_INFO << "  --> Validating output directory...";

	if (ValidateLang(dir, false, false) < 0) {
		LOGTW_ERROR << "Error validating output.";
		return -1;
	}

	//cleanup temp files
	DeleteAllMatching(tmpdir, boost::regex(".*(\\.temp)$"));
	DeleteAllMatching(path_phones, boost::regex(".*(\\.temp)$"));
	
	return 0;
}

